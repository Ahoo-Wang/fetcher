# 集成测试

此目录包含 Fetcher 库及其扩展的集成测试。这些测试验证各个组件是否能正确协同工作并与外部服务交互。

## 目录结构

- `src/` - 测试对象和工具
    - `cosec/` - COSEC 集成测试
    - `decorator/` - 装饰器模式集成测试
    - `eventstream/` - 事件流集成测试
    - `fetcher/` - 核心 fetcher 集成测试
- `test/` - 实际测试文件
    - `cosec/` - COSEC 集成测试实现
    - `decorator/` - 装饰器模式集成测试实现
    - `eventstream/` - 事件流集成测试实现
    - `fetcher/` - 核心 fetcher 集成测试实现

## 运行测试

运行所有集成测试：

```bash
pnpm test
```

运行特定测试文件：

```bash
pnpm test test/<path-to-test-file>
```

例如：

```bash
pnpm test test/fetcher/typicodeFetcher.test.ts
```

## 测试对象

### Typicode Fetcher

测试核心 Fetcher 功能与 JSONPlaceholder API (https://jsonplaceholder.typicode.com) 的交互。验证：

- GET, POST, PUT, PATCH, 和 DELETE 操作
- 请求/响应处理
- 拦截器功能

### COSEC 集成

测试 COSEC 安全扩展，包括：

- 请求签名
- 响应验证
- 令牌管理
- 设备 ID 处理

### 装饰器模式

测试装饰器扩展，提供：

- API 端点定义
- 参数处理
- 结果提取
- 方法映射 (GET, POST, 等)

### 事件流

测试事件流扩展，包括：

- 服务器发送事件 (SSE) 处理
- JSON 事件流处理
- LLM 客户端集成

## 使用示例

`src/` 目录中的文件也作为各种 Fetcher 组件的使用示例：

### 核心 Fetcher 使用

```typescript
// integration-test/src/fetcher/typicodeFetcher.ts
import { NamedFetcher } from '@ahoo-wang/fetcher';
import { cosecRequestInterceptor, cosecResponseInterceptor } from '../cosec';

export const typicodeFetcher = new NamedFetcher('typicode', {
  baseURL: 'https://jsonplaceholder.typicode.com',
});

typicodeFetcher.interceptors.request.use(cosecRequestInterceptor);
typicodeFetcher.interceptors.response.use(cosecResponseInterceptor);
```

### 装饰器模式使用

```typescript
// integration-test/src/decorator/typicodePostService.ts
import {
  api,
  autoGeneratedError,
  body,
  del,
  get,
  post,
  patch,
  path,
  put,
  query,
} from '@ahoo-wang/fetcher-decorator';
import { typicodeFetcher } from '../fetcher';
import { Post } from '../types';

@api('/posts', { fetcher: typicodeFetcher })
export class TypicodePostService {
  @get('')
  getPosts(): Promise<Post[]> {
    throw autoGeneratedError();
  }

  @get('/{postId}')
  getPost(@path('postId') postId: string): Promise<Post> {
    throw autoGeneratedError();
  }

  @post('')
  createPost(@body() post: Post): Promise<Post> {
    throw autoGeneratedError();
  }

  @put('/{postId}')
  updatePost(
    @path('postId') postId: string,
    @body() post: Post,
  ): Promise<Post> {
    throw autoGeneratedError();
  }

  @patch('/{postId}')
  patchPost(
    @path('postId') postId: string,
    @body() post: Partial<Post>,
  ): Promise<Post> {
    throw autoGeneratedError();
  }

  @del('/{postId}')
  deletePost(@path('postId') postId: string): Promise<object> {
    throw autoGeneratedError();
  }

  @get('')
  filterPosts(
    @query('userId') userId?: string,
    @query('completed') completed?: boolean,
  ): Promise<Post[]> {
    throw autoGeneratedError();
  }
}

export const typicodePostService = new TypicodePostService();
```

### COSEC 安全使用

```typescript
// integration-test/src/cosec/cosec.ts
import {
  CompositeToken,
  CoSecOptions,
  CoSecRequestInterceptor,
  CoSecResponseInterceptor,
  DeviceIdStorage,
  TokenRefresher,
  TokenStorage,
} from '@ahoo-wang/fetcher-cosec';

export class MockTokenRefresher implements TokenRefresher {
  refresh(token: CompositeToken): Promise<CompositeToken> {
    return Promise.reject('Token refresh failed');
  }
}

const cosecOptions: CoSecOptions = {
  appId: 'appId',
  deviceIdStorage: new DeviceIdStorage(),
  tokenStorage: new TokenStorage(),
  tokenRefresher: new MockTokenRefresher(),
};

export const cosecRequestInterceptor = new CoSecRequestInterceptor(
  cosecOptions,
);
export const cosecResponseInterceptor = new CoSecResponseInterceptor(
  cosecOptions,
);
```

### 事件流使用

```typescript
// integration-test/src/eventstream/llmClient.ts
import {
  BaseURLCapable,
  ContentTypeValues,
  FetchExchange,
  NamedFetcher,
  REQUEST_BODY_INTERCEPTOR_ORDER,
  RequestInterceptor,
} from '@ahoo-wang/fetcher';
import {
  api,
  autoGeneratedError,
  body,
  post,
  ResultExtractors,
} from '@ahoo-wang/fetcher-decorator';
import {
  EventStreamInterceptor,
  JsonServerSentEventStream,
} from '@ahoo-wang/fetcher-eventstream';
import { ChatRequest, ChatResponse } from './types';

export const llmFetcherName = 'llm';

export interface LlmOptions extends BaseURLCapable {
  apiKey: string;
  model?: string;
}

export class LlmRequestInterceptor implements RequestInterceptor {
  readonly name: string = 'LlmRequestInterceptor';
  readonly order: number = REQUEST_BODY_INTERCEPTOR_ORDER - 1;

  constructor(private llmOptions: LlmOptions) {}

  intercept(exchange: FetchExchange): void {
    const chatRequest = exchange.request.body as ChatRequest;
    if (!chatRequest.model) {
      chatRequest.model = this.llmOptions.model;
    }
  }
}

export function createLlmFetcher(options: LlmOptions): NamedFetcher {
  const llmFetcher = new NamedFetcher(llmFetcherName, {
    baseURL: options.baseURL,
    headers: {
      Authorization: `Bearer ${options.apiKey}`,
      'Content-Type': ContentTypeValues.APPLICATION_JSON,
    },
  });
  llmFetcher.interceptors.request.use(new LlmRequestInterceptor(options));
  llmFetcher.interceptors.response.use(new EventStreamInterceptor());
  return llmFetcher;
}

@api('/chat', {
  fetcher: llmFetcherName,
  resultExtractor: ResultExtractors.JsonEventStream,
})
export class LlmClient {
  @post('/completions')
  streamChat(
    @body() body: ChatRequest,
  ): Promise<JsonServerSentEventStream<ChatResponse>> {
    throw autoGeneratedError();
  }

  @post('/completions', { resultExtractor: ResultExtractors.Json })
  chat(@body() body: ChatRequest): Promise<ChatResponse> {
    throw autoGeneratedError();
  }
}
```

## 环境变量

某些测试需要设置环境变量：

### LLM 客户端测试

要测试 LLM 客户端功能，请设置以下环境变量：

- `LLM_BASE_URL` - LLM API 的基础 URL
- `LLM_API_KEY` - 用于认证的 API 密钥
- `LLM_MODEL` - (可选) 要使用的默认模型

示例：

```bash
export LLM_BASE_URL="https://api.openai.com"
export LLM_API_KEY="your-api-key-here"
pnpm test test/eventstream/llmClient.test.ts
```

如果未设置这些环境变量，LLM 测试将自动跳过。

## 添加新测试

1. 在 `test/` 下的相应目录中创建新的测试文件
2. 导入要测试的组件
3. 使用 Vitest 框架编写测试用例
4. 确保测试是独立的，不依赖外部状态
5. 为外部服务测试添加所需的环境变量处理

## 代码覆盖率

测试套件包含代码覆盖率报告。运行测试后，覆盖率信息将显示在控制台中，并在 `coverage/` 目录中生成 HTML 报告。
