# Integration Tests

This directory contains integration tests for the Fetcher library and its extensions. These tests verify that the
various components work correctly together and with external services.

## Structure

- `src/` - Test subjects and utilities
    - `cosec/` - COSEC integration tests
    - `decorator/` - Decorator pattern integration tests
    - `eventstream/` - Event stream integration tests
    - `fetcher/` - Core fetcher integration tests
- `test/` - Actual test files
    - `cosec/` - COSEC integration test implementations
    - `decorator/` - Decorator pattern integration test implementations
    - `eventstream/` - Event stream integration test implementations
    - `fetcher/` - Core fetcher integration test implementations

## Running Tests

To run all integration tests:

```bash
pnpm test
```

To run a specific test file:

```bash
pnpm test test/<path-to-test-file>
```

For example:

```bash
pnpm test test/fetcher/typicodeFetcher.test.ts
```

## Test Subjects

### Typicode Fetcher

Tests the core Fetcher functionality against the JSONPlaceholder API (https://jsonplaceholder.typicode.com). This
verifies:

- GET, POST, PUT, PATCH, and DELETE operations
- Request/response handling
- Interceptor functionality

### COSEC Integration

Tests the COSEC security extension including:

- Request signing
- Response validation
- Token management
- Device ID handling

### Decorator Pattern

Tests the decorator extension that provides:

- API endpoint definitions
- Parameter handling
- Result extraction
- Method mapping (GET, POST, etc.)

### Event Stream

Tests the event stream extension for:

- Server-Sent Events (SSE) handling
- JSON event stream processing
- LLM client integration

## Usage Examples

The files in `src/` also serve as usage examples for the various Fetcher components:

### Core Fetcher Usage

```typescript
// integration-test/src/fetcher/typicodeFetcher.ts
import { NamedFetcher } from '@ahoo-wang/fetcher';
import { cosecRequestInterceptor, cosecResponseInterceptor } from '../cosec';

export const typicodeFetcher = new NamedFetcher('typicode', {
  baseURL: 'https://jsonplaceholder.typicode.com',
});

typicodeFetcher.interceptors.request.use(cosecRequestInterceptor);
typicodeFetcher.interceptors.response.use(cosecResponseInterceptor);
```

### Decorator Pattern Usage

```typescript
// integration-test/src/decorator/typicodePostService.ts
import {
  api,
  autoGeneratedError,
  body,
  del,
  get,
  post,
  patch,
  path,
  put,
  query,
} from '@ahoo-wang/fetcher-decorator';
import { typicodeFetcher } from '../fetcher';
import { Post } from '../types';

@api('/posts', { fetcher: typicodeFetcher })
export class TypicodePostService {
  @get('')
  getPosts(): Promise<Post[]> {
    throw autoGeneratedError();
  }

  @get('/{postId}')
  getPost(@path('postId') postId: string): Promise<Post> {
    throw autoGeneratedError();
  }

  @post('')
  createPost(@body() post: Post): Promise<Post> {
    throw autoGeneratedError();
  }

  @put('/{postId}')
  updatePost(
    @path('postId') postId: string,
    @body() post: Post,
  ): Promise<Post> {
    throw autoGeneratedError();
  }

  @patch('/{postId}')
  patchPost(
    @path('postId') postId: string,
    @body() post: Partial<Post>,
  ): Promise<Post> {
    throw autoGeneratedError();
  }

  @del('/{postId}')
  deletePost(@path('postId') postId: string): Promise<object> {
    throw autoGeneratedError();
  }

  @get('')
  filterPosts(
    @query('userId') userId?: string,
    @query('completed') completed?: boolean,
  ): Promise<Post[]> {
    throw autoGeneratedError();
  }
}

export const typicodePostService = new TypicodePostService();
```

### COSEC Security Usage

```typescript
// integration-test/src/cosec/cosec.ts
import {
  CompositeToken,
  CoSecOptions,
  CoSecRequestInterceptor,
  CoSecResponseInterceptor,
  DeviceIdStorage,
  TokenRefresher,
  TokenStorage,
} from '@ahoo-wang/fetcher-cosec';

export class MockTokenRefresher implements TokenRefresher {
  refresh(token: CompositeToken): Promise<CompositeToken> {
    return Promise.reject('Token refresh failed');
  }
}

const cosecOptions: CoSecOptions = {
  appId: 'appId',
  deviceIdStorage: new DeviceIdStorage(),
  tokenStorage: new TokenStorage(),
  tokenRefresher: new MockTokenRefresher(),
};

export const cosecRequestInterceptor = new CoSecRequestInterceptor(
  cosecOptions,
);
export const cosecResponseInterceptor = new CoSecResponseInterceptor(
  cosecOptions,
);
```

### Event Stream Usage

```typescript
// integration-test/src/eventstream/llmClient.ts
import {
  BaseURLCapable,
  ContentTypeValues,
  FetchExchange,
  NamedFetcher,
  REQUEST_BODY_INTERCEPTOR_ORDER,
  RequestInterceptor,
} from '@ahoo-wang/fetcher';
import {
  api,
  autoGeneratedError,
  body,
  post,
  ResultExtractors,
} from '@ahoo-wang/fetcher-decorator';
import {
  EventStreamInterceptor,
  JsonServerSentEventStream,
} from '@ahoo-wang/fetcher-eventstream';
import { ChatRequest, ChatResponse } from './types';

export const llmFetcherName = 'llm';

export interface LlmOptions extends BaseURLCapable {
  apiKey: string;
  model?: string;
}

export class LlmRequestInterceptor implements RequestInterceptor {
  readonly name: string = 'LlmRequestInterceptor';
  readonly order: number = REQUEST_BODY_INTERCEPTOR_ORDER - 1;

  constructor(private llmOptions: LlmOptions) {}

  intercept(exchange: FetchExchange): void {
    const chatRequest = exchange.request.body as ChatRequest;
    if (!chatRequest.model) {
      chatRequest.model = this.llmOptions.model;
    }
  }
}

export function createLlmFetcher(options: LlmOptions): NamedFetcher {
  const llmFetcher = new NamedFetcher(llmFetcherName, {
    baseURL: options.baseURL,
    headers: {
      Authorization: `Bearer ${options.apiKey}`,
      'Content-Type': ContentTypeValues.APPLICATION_JSON,
    },
  });
  llmFetcher.interceptors.request.use(new LlmRequestInterceptor(options));
  llmFetcher.interceptors.response.use(new EventStreamInterceptor());
  return llmFetcher;
}

@api('/chat', {
  fetcher: llmFetcherName,
  resultExtractor: ResultExtractors.JsonEventStream,
})
export class LlmClient {
  @post('/completions')
  streamChat(
    @body() body: ChatRequest,
  ): Promise<JsonServerSentEventStream<ChatResponse>> {
    throw autoGeneratedError();
  }

  @post('/completions', { resultExtractor: ResultExtractors.Json })
  chat(@body() body: ChatRequest): Promise<ChatResponse> {
    throw autoGeneratedError();
  }
}
```

## Environment Variables

Some tests require environment variables to be set:

### LLM Client Tests

For testing LLM client functionality, set these environment variables:

- `LLM_BASE_URL` - Base URL for the LLM API
- `LLM_API_KEY` - API key for authentication
- `LLM_MODEL` - (Optional) Default model to use

Example:

```bash
export LLM_BASE_URL="https://api.openai.com"
export LLM_API_KEY="your-api-key-here"
pnpm test test/eventstream/llmClient.test.ts
```

If these environment variables are not set, the LLM tests will be skipped automatically.

## Adding New Tests

1. Create a new test file in the appropriate directory under `test/`
2. Import the components you want to test
3. Write test cases using the Vitest framework
4. Ensure tests are self-contained and don't depend on external state
5. Add any required environment variable handling for external service tests

## Code Coverage

The test suite includes code coverage reporting. After running tests, coverage information will be displayed in the
console and HTML reports will be generated in the `coverage/` directory.
