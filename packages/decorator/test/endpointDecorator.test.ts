import { describe, it, expect } from 'vitest';
import 'reflect-metadata';
import {
  HttpMethod,
  ExchangeResultExtractor,
  JsonResultExtractor,
} from '@ahoo-wang/fetcher';
import {
  endpoint,
  get,
  post,
  put,
  del,
  patch,
  head,
  options,
  ENDPOINT_METADATA_KEY,
  type EndpointMetadata,
} from '../src';
import { autoGeneratedError } from '../src';

describe('endpointDecorator', () => {
  describe('ENDPOINT_METADATA_KEY', () => {
    it('should define endpoint metadata key symbol', () => {
      expect(ENDPOINT_METADATA_KEY).toBeTypeOf('symbol');
    });
  });

  describe('endpoint', () => {
    it('should create endpoint decorator with method and path', () => {
      class TestClass {
        @endpoint(HttpMethod.GET, '/users')
        getUsers() {
          throw autoGeneratedError();
        }
      }

      const metadata: EndpointMetadata = Reflect.getMetadata(
        ENDPOINT_METADATA_KEY,
        TestClass.prototype,
        'getUsers',
      );

      expect(metadata).toBeDefined();
      expect(metadata.method).toBe(HttpMethod.GET);
      expect(metadata.path).toBe('/users');
    });

    it('should create endpoint decorator with method, path and additional metadata', () => {
      const customMetadata = {
        headers: { 'X-Custom': 'value' },
        timeout: 5000,
        resultExtractor: ExchangeResultExtractor,
      };

      class TestClass {
        @endpoint(HttpMethod.POST, '/users', customMetadata)
        createUsers() {
          throw autoGeneratedError();
        }
      }

      const metadata: EndpointMetadata = Reflect.getMetadata(
        ENDPOINT_METADATA_KEY,
        TestClass.prototype,
        'createUsers',
      );

      expect(metadata).toBeDefined();
      expect(metadata.method).toBe(HttpMethod.POST);
      expect(metadata.path).toBe('/users');
      expect(metadata.headers).toEqual({ 'X-Custom': 'value' });
      expect(metadata.timeout).toBe(5000);
      expect(metadata.resultExtractor).toBe(ExchangeResultExtractor);
    });

    it('should create endpoint decorator with only method', () => {
      class TestClass {
        @endpoint(HttpMethod.PUT)
        updateUsers() {
          throw autoGeneratedError();
        }
      }

      const metadata: EndpointMetadata = Reflect.getMetadata(
        ENDPOINT_METADATA_KEY,
        TestClass.prototype,
        'updateUsers',
      );

      expect(metadata).toBeDefined();
      expect(metadata.method).toBe(HttpMethod.PUT);
      expect(metadata.path).toBeUndefined();
    });

    it('should create endpoint decorator with no parameters', () => {
      class TestClass {
        @endpoint()
        defaultMethod() {
          throw autoGeneratedError();
        }
      }

      const metadata: EndpointMetadata = Reflect.getMetadata(
        ENDPOINT_METADATA_KEY,
        TestClass.prototype,
        'defaultMethod',
      );

      expect(metadata).toBeDefined();
      expect(metadata.method).toBeUndefined();
      expect(metadata.path).toBeUndefined();
    });
  });

  describe('get', () => {
    it('should create GET endpoint decorator with path', () => {
      class TestClass {
        @get('/users')
        getUsers() {
          throw autoGeneratedError();
        }
      }

      const metadata: EndpointMetadata = Reflect.getMetadata(
        ENDPOINT_METADATA_KEY,
        TestClass.prototype,
        'getUsers',
      );

      expect(metadata).toBeDefined();
      expect(metadata.method).toBe(HttpMethod.GET);
      expect(metadata.path).toBe('/users');
    });

    it('should create GET endpoint decorator with path and metadata', () => {
      const customMetadata = {
        resultExtractor: JsonResultExtractor,
      };

      class TestClass {
        @get('/users', customMetadata)
        getUsers() {
          throw autoGeneratedError();
        }
      }

      const metadata: EndpointMetadata = Reflect.getMetadata(
        ENDPOINT_METADATA_KEY,
        TestClass.prototype,
        'getUsers',
      );

      expect(metadata).toBeDefined();
      expect(metadata.method).toBe(HttpMethod.GET);
      expect(metadata.path).toBe('/users');
      expect(metadata.resultExtractor).toBe(JsonResultExtractor);
    });

    it('should create GET endpoint decorator with default path', () => {
      class TestClass {
        @get()
        getUsers() {
          throw autoGeneratedError();
        }
      }

      const metadata: EndpointMetadata = Reflect.getMetadata(
        ENDPOINT_METADATA_KEY,
        TestClass.prototype,
        'getUsers',
      );

      expect(metadata).toBeDefined();
      expect(metadata.method).toBe(HttpMethod.GET);
      expect(metadata.path).toBe('');
    });
  });

  describe('post', () => {
    it('should create POST endpoint decorator', () => {
      class TestClass {
        @post('/users')
        createUsers() {
          throw autoGeneratedError();
        }
      }

      const metadata: EndpointMetadata = Reflect.getMetadata(
        ENDPOINT_METADATA_KEY,
        TestClass.prototype,
        'createUsers',
      );

      expect(metadata).toBeDefined();
      expect(metadata.method).toBe(HttpMethod.POST);
      expect(metadata.path).toBe('/users');
    });
  });

  describe('put', () => {
    it('should create PUT endpoint decorator', () => {
      class TestClass {
        @put('/users/{id}')
        updateUsers() {
          throw autoGeneratedError();
        }
      }

      const metadata: EndpointMetadata = Reflect.getMetadata(
        ENDPOINT_METADATA_KEY,
        TestClass.prototype,
        'updateUsers',
      );

      expect(metadata).toBeDefined();
      expect(metadata.method).toBe(HttpMethod.PUT);
      expect(metadata.path).toBe('/users/{id}');
    });
  });

  describe('del', () => {
    it('should create DELETE endpoint decorator', () => {
      class TestClass {
        @del('/users/{id}')
        deleteUsers() {
          throw autoGeneratedError();
        }
      }

      const metadata: EndpointMetadata = Reflect.getMetadata(
        ENDPOINT_METADATA_KEY,
        TestClass.prototype,
        'deleteUsers',
      );

      expect(metadata).toBeDefined();
      expect(metadata.method).toBe(HttpMethod.DELETE);
      expect(metadata.path).toBe('/users/{id}');
    });
  });

  describe('patch', () => {
    it('should create PATCH endpoint decorator', () => {
      class TestClass {
        @patch('/users/{id}')
        patchUsers() {
          throw autoGeneratedError();
        }
      }

      const metadata: EndpointMetadata = Reflect.getMetadata(
        ENDPOINT_METADATA_KEY,
        TestClass.prototype,
        'patchUsers',
      );

      expect(metadata).toBeDefined();
      expect(metadata.method).toBe(HttpMethod.PATCH);
      expect(metadata.path).toBe('/users/{id}');
    });
  });

  describe('head', () => {
    it('should create HEAD endpoint decorator', () => {
      class TestClass {
        @head('/users')
        headUsers() {
          throw autoGeneratedError();
        }
      }

      const metadata: EndpointMetadata = Reflect.getMetadata(
        ENDPOINT_METADATA_KEY,
        TestClass.prototype,
        'headUsers',
      );

      expect(metadata).toBeDefined();
      expect(metadata.method).toBe(HttpMethod.HEAD);
      expect(metadata.path).toBe('/users');
    });
  });

  describe('options', () => {
    it('should create OPTIONS endpoint decorator', () => {
      class TestClass {
        @options('/users')
        optionsUsers() {
          throw autoGeneratedError();
        }
      }

      const metadata: EndpointMetadata = Reflect.getMetadata(
        ENDPOINT_METADATA_KEY,
        TestClass.prototype,
        'optionsUsers',
      );

      expect(metadata).toBeDefined();
      expect(metadata.method).toBe(HttpMethod.OPTIONS);
      expect(metadata.path).toBe('/users');
    });
  });
});