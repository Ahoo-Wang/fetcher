import { describe, it, expect, vi } from 'vitest';
import 'reflect-metadata';
import { HttpMethod, type Fetcher, fetcherRegistrar } from '@ahoo-wang/fetcher';
import { buildRequestExecutor, api } from '../src';
import { endpoint } from '../src';
import { RequestExecutor } from '../src';
import { autoGeneratedError } from '../src';

// Mock fetcher
const mockFetcher: Fetcher = {
  name: 'mock',
  fetch: vi.fn().mockResolvedValue({
    ok: true,
    status: 200,
    headers: new Map(),
    text: vi.fn().mockResolvedValue('{"data": "test"}'),
    json: vi.fn().mockResolvedValue({ data: 'test' }),
  }),
};

// Register mock fetcher
fetcherRegistrar.register('mock', mockFetcher);

@api('/test')
class TestApiWithExecutor {
  @endpoint(HttpMethod.GET, '/data')
  getData() {
    throw autoGeneratedError();
  }
}

describe('buildRequestExecutor', () => {
  it('should return existing requestExecutor if it exists on target', () => {
    const target = new TestApiWithExecutor();
    const mockExecutor = new RequestExecutor({
      name: 'test',
    } as any);

    target['requestExecutor'] = mockExecutor;

    const result = buildRequestExecutor(target, {
      name: 'test',
    } as any);

    expect(result).toBe(mockExecutor);
  });

  it('should create new RequestExecutor with default metadata when no apiMetadata exists', () => {
    const target = {};
    const defaultFunctionMetadata = {
      name: 'testFunction',
    };
    
    const result = buildRequestExecutor(target, defaultFunctionMetadata as any);

    expect(result).toBeInstanceOf(RequestExecutor);
    expect(target['requestExecutor']).toBe(result);
  });

  it('should create new RequestExecutor with merged metadata when apiMetadata exists', () => {
    const apiMetadata = {
      basePath: '/api',
      headers: { 'X-Test': 'value' },
    };

    const target = {
      apiMetadata,
    };

    const defaultFunctionMetadata = {
      name: 'testFunction',
      endpoint: {
        method: HttpMethod.GET,
        path: '/endpoint',
      },
      parameters: new Map(),
    };

    const result = buildRequestExecutor(target, defaultFunctionMetadata as any);

    expect(result).toBeInstanceOf(RequestExecutor);
    expect(target['requestExecutor']).toBe(result);
  });
});

describe('bindExecutor', () => {
  it('should not bind executor to constructor method', () => {
    // This is implicitly tested by checking that the constructor is not modified
    const originalConstructor = TestApiWithExecutor.prototype.constructor;
    expect(originalConstructor).toBe(TestApiWithExecutor);
  });

  it('should not bind executor to non-function properties', () => {
    // Create an instance and verify non-function properties are unchanged
    const instance = new TestApiWithExecutor();
    instance['nonFunctionProperty'] = 'test-value';
    expect(instance['nonFunctionProperty']).toBe('test-value');
  });

  it('should not bind executor to methods without endpoint metadata', () => {
    @api('/test')
    class TestApiWithoutEndpoint {
      regularMethod() {
        return 'regular';
      }
    }

    const instance = new TestApiWithoutEndpoint();
    expect(instance.regularMethod()).toBe('regular');
  });

  it('should bind executor to methods with endpoint metadata', () => {
    const instance = new TestApiWithExecutor();
    // The method should be replaced with a function that executes requests
    expect(typeof instance.getData).toBe('function');
    // It should not be the original autoGeneratedError function
    // We're not calling the method to avoid actual network requests in tests
  });
});