import { describe, it, expect } from 'vitest';
import * as index from '../src/index';
import { API_METADATA_KEY } from '../src';
import { PARAMETER_METADATA_KEY, ParameterType } from '../src';

describe('index', () => {
  it('should export all decorators and utilities', () => {
    // Check that all expected exports are present
    expect(typeof index.api).toBe('function');
    expect(typeof index.get).toBe('function');
    expect(typeof index.path).toBe('function');
    expect(typeof index.getParameterNames).toBe('function');
    expect(typeof index.FunctionMetadata).toBe('function');
    expect(typeof index.autoGeneratedError).toBe('function');
  });

  it('should have all decorator types available', () => {
    // Test that we can use the exported decorators
    @index.api('/test')
    class TestService {
      @index.get('/users')
      getUsers() {
        throw index.autoGeneratedError();
      }
    }

    const metadata = Reflect.getMetadata(API_METADATA_KEY, TestService);
    expect(metadata).toBeDefined();
    expect(metadata.basePath).toBe('/test');
  });

  it('should have all parameter decorators available', () => {
    // Test that we can use the exported parameter decorators
    @index.api('/test')
    class TestService {
      @index.get('/users/{id}')
      getUser(@index.path('id') id: number) {
        throw index.autoGeneratedError();
      }
    }

    const instance = new TestService();
    const parameterMetadata = Reflect.getMetadata(
      PARAMETER_METADATA_KEY,
      Object.getPrototypeOf(instance),
      'getUser',
    );

    expect(parameterMetadata).toEqual([
      {
        type: ParameterType.PATH,
        name: 'id',
        index: 0,
      },
    ]);
  });

  it('should have reflection utilities available', () => {
    function testFunc(a: string, b: number) {
      return a.length + b;
    }

    const paramNames = index.getParameterNames(testFunc);
    expect(paramNames).toEqual(['a', 'b']);
  });
});
