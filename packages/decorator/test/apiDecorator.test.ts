import { describe, it, expect, vi, beforeAll, afterAll } from 'vitest';
import 'reflect-metadata';
import { JsonResultExtractor, HttpMethod } from '@ahoo-wang/fetcher';
import {
  api,
  API_METADATA_KEY,
  type ApiMetadata,
  buildRequestExecutor,
} from '../src';
import { endpoint } from '../src';
import { parameter, ParameterType } from '../src';
import { autoGeneratedError } from '../src';
import { RequestExecutor } from '../src';
import { FunctionMetadata } from '../src';

// Mock fetch globally to prevent actual HTTP requests
const originalFetch = global.fetch;
beforeAll(() => {
  global.fetch = vi.fn(() =>
    Promise.resolve({
      ok: true,
      status: 200,
      json: () => Promise.resolve({ mocked: 'response' }),
      text: () => Promise.resolve('mocked response'),
    } as Response),
  );
});

afterAll(() => {
  global.fetch = originalFetch;
});

afterAll(() => {
  global.fetch = originalFetch;
});

// Mock class for testing decorators
@api('/api/v1', {
  headers: { 'X-Default': 'value' },
  timeout: 3000,
  resultExtractor: JsonResultExtractor,
})
class TestApi {
  @endpoint(HttpMethod.GET, '/users')
  getUsers() {
    throw autoGeneratedError();
  }

  @endpoint(HttpMethod.GET, '/users/{id}')
  getUser(@parameter(ParameterType.PATH, 'id') id: string) {
    throw autoGeneratedError();
  }

  notDecoratedMethod() {
    return 'not decorated';
  }

  nonFunctionProperty = 'value';
}

// Another test class with minimal configuration
@api()
class MinimalApi {
  @endpoint(HttpMethod.POST, '/data')
  postData() {
    throw autoGeneratedError();
  }
}

describe('apiDecorator', () => {
  describe('API_METADATA_KEY', () => {
    it('should define API metadata key symbol', () => {
      expect(API_METADATA_KEY).toBeTypeOf('symbol');
    });
  });

  describe('api', () => {
    it('should create API decorator with base path and metadata', () => {
      const metadata: ApiMetadata = Reflect.getMetadata(
        API_METADATA_KEY,
        TestApi,
      );

      expect(metadata).toBeDefined();
      expect(metadata.basePath).toBe('/api/v1');
      expect(metadata.headers).toEqual({ 'X-Default': 'value' });
      expect(metadata.timeout).toBe(3000);
      expect(metadata.resultExtractor).toBe(JsonResultExtractor);
    });

    it('should create API decorator with default parameters', () => {
      const metadata: ApiMetadata = Reflect.getMetadata(
        API_METADATA_KEY,
        MinimalApi,
      );

      expect(metadata).toBeDefined();
      expect(metadata.basePath).toBe('');
      expect(metadata.headers).toBeUndefined();
      expect(metadata.timeout).toBeUndefined();
      expect(metadata.resultExtractor).toBeUndefined();
      expect(metadata.fetcher).toBeUndefined();
    });

    it('should store metadata on the class constructor', () => {
      const metadata: ApiMetadata = Reflect.getMetadata(
        API_METADATA_KEY,
        TestApi,
      );

      expect(metadata).toBeDefined();
      expect(metadata.basePath).toBe('/api/v1');
    });

    it('should replace decorated methods with executable functions', () => {
      const testApi = new TestApi();

      expect(typeof testApi.getUsers).toBe('function');
      expect(typeof testApi.getUser).toBe('function');
      // Non-decorated methods should remain unchanged
      expect(typeof testApi.notDecoratedMethod).toBe('function');
      expect(testApi.nonFunctionProperty).toBe('value');
    });

    it('should preserve non-decorated methods and properties', () => {
      const testApi = new TestApi();

      expect(testApi.notDecoratedMethod()).toBe('not decorated');
      expect(testApi.nonFunctionProperty).toBe('value');
    });

    it('should handle class with no endpoint decorators', () => {
      @api('/test')
      class NoEndpointsApi {
        regularMethod() {
          return 'regular';
        }
      }

      const metadata: ApiMetadata = Reflect.getMetadata(
        API_METADATA_KEY,
        NoEndpointsApi,
      );

      expect(metadata).toBeDefined();
      expect(metadata.basePath).toBe('/test');

      const noEndpointsApi = new NoEndpointsApi();
      expect(noEndpointsApi.regularMethod()).toBe('regular');
    });

    it('should handle class with mixed decorated and non-decorated methods', () => {
      @api('/mixed')
      class MixedApi {
        @endpoint(HttpMethod.GET, '/endpoint')
        decoratedMethod() {
          throw autoGeneratedError();
        }

        nonDecoratedMethod() {
          return 'non-decorated';
        }

        anotherNonDecoratedMethod() {
          return 'another non-decorated';
        }
      }

      const metadata: ApiMetadata = Reflect.getMetadata(
        API_METADATA_KEY,
        MixedApi,
      );

      expect(metadata).toBeDefined();
      expect(metadata.basePath).toBe('/mixed');

      const mixedApi = new MixedApi();
      expect(typeof mixedApi.decoratedMethod).toBe('function');
      expect(mixedApi.nonDecoratedMethod()).toBe('non-decorated');
      expect(mixedApi.anotherNonDecoratedMethod()).toBe(
        'another non-decorated',
      );
    });
  });

  describe('bindExecutor', () => {
    it('should not bind executor to constructor', () => {
      // This test ensures that the constructor is not modified by the decorator
      expect(TestApi.prototype.constructor).toBe(TestApi);
    });

    it('should not bind executor to non-function properties', () => {
      const testApi = new TestApi();
      // Non-function properties should remain unchanged
      expect(testApi.nonFunctionProperty).toBe('value');
    });

    it('should not bind executor to methods without endpoint metadata', () => {
      const testApi = new TestApi();
      // Methods without @endpoint decorator should remain unchanged
      expect(testApi.notDecoratedMethod()).toBe('not decorated');
    });

    it('should bind executor to decorated methods', () => {
      const testApi = new TestApi();
      // Decorated methods should be replaced with functions
      expect(typeof testApi.getUsers).toBe('function');
      expect(typeof testApi.getUser).toBe('function');
    });
  });

  describe('inheritance support', () => {
    it('should handle inherited decorated methods', () => {
      @api('/base')
      class BaseApi {
        @endpoint(HttpMethod.GET, '/base-endpoint')
        baseMethod() {
          throw autoGeneratedError();
        }
      }

      @api('/child')
      class ChildApi extends BaseApi {
        @endpoint(HttpMethod.POST, '/child-endpoint')
        childMethod() {
          throw autoGeneratedError();
        }
      }

      const childApi = new ChildApi();

      // Both base and child methods should be decorated
      expect(typeof childApi.baseMethod).toBe('function');
      expect(typeof childApi.childMethod).toBe('function');

      // Child metadata should override base
      const childMetadata: ApiMetadata = Reflect.getMetadata(
        API_METADATA_KEY,
        ChildApi,
      );
      expect(childMetadata.basePath).toBe('/child');
    });
  });

  describe('error handling', () => {
    it('should handle invalid target object gracefully', () => {
      const functionMetadata = new FunctionMetadata(
        'testMethod',
        {},
        { method: HttpMethod.GET, path: '/test' },
        new Map(),
      );

      expect(() =>
        buildRequestExecutor(null as any, functionMetadata),
      ).toThrow();
      expect(() =>
        buildRequestExecutor(undefined as any, functionMetadata),
      ).toThrow();
    });

    it('should not bind executor to methods without endpoint metadata', () => {
      @api('/test')
      class ApiWithoutEndpoints {
        methodWithoutEndpoint() {
          return 'original';
        }
      }

      const apiInstance = new ApiWithoutEndpoints();
      expect(apiInstance.methodWithoutEndpoint()).toBe('original');
    });
  });

  describe('type safety', () => {
    it('should handle fetcher as string or Fetcher instance', () => {
      @api('/test', { fetcher: 'customFetcher' })
      class ApiWithStringFetcher {
        @endpoint(HttpMethod.GET, '/test')
        testMethod() {
          throw autoGeneratedError();
        }
      }

      const metadata: ApiMetadata = Reflect.getMetadata(
        API_METADATA_KEY,
        ApiWithStringFetcher,
      );

      expect(metadata.fetcher).toBe('customFetcher');

      // Test with Fetcher instance (mock)
      const mockFetcher = { fetch: vi.fn() };
      @api('/test2', { fetcher: mockFetcher as any })
      class ApiWithFetcherInstance {
        @endpoint(HttpMethod.GET, '/test2')
        testMethod() {
          throw autoGeneratedError();
        }
      }

      const metadata2: ApiMetadata = Reflect.getMetadata(
        API_METADATA_KEY,
        ApiWithFetcherInstance,
      );

      expect(metadata2.fetcher).toBe(mockFetcher);
    });

    it('should validate ApiMetadata interface compatibility', () => {
      const validMetadata: ApiMetadata = {
        basePath: '/test',
        headers: { 'X-Test': 'value' },
        timeout: 5000,
        fetcher: 'default',
        resultExtractor: JsonResultExtractor,
        attributes: {},
        urlParams: {},
      };

      @api(validMetadata.basePath!, {
        headers: validMetadata.headers,
        timeout: validMetadata.timeout,
        fetcher: validMetadata.fetcher,
        resultExtractor: validMetadata.resultExtractor,
        attributes: validMetadata.attributes,
        urlParams: validMetadata.urlParams,
      })
      class ValidApi {
        @endpoint(HttpMethod.GET, '/test')
        testMethod() {
          throw autoGeneratedError();
        }
      }

      const metadata: ApiMetadata = Reflect.getMetadata(
        API_METADATA_KEY,
        ValidApi,
      );

      expect(metadata).toMatchObject(validMetadata);
    });
  });

  describe('boundary cases', () => {
    it('should handle empty parameter metadata', () => {
      const testApi = new TestApi();
      const functionMetadata = new FunctionMetadata(
        'getUsers',
        {},
        { method: HttpMethod.GET, path: '/users' },
        new Map(), // Empty parameter metadata
      );

      const requestExecutor = buildRequestExecutor(testApi, functionMetadata);

      expect(requestExecutor).toBeInstanceOf(RequestExecutor);
    });

    it('should handle multiple api decorators on same class', () => {
      // Note: Multiple @api decorators on same class is not recommended,
      // but we should test the behavior
      expect(() => {
        @api('/first')
        @api('/second') // Decorators are applied from bottom to top
        class MultipleApiDecorators {
          @endpoint(HttpMethod.GET, '/test')
          testMethod() {
            throw autoGeneratedError();
          }
        }

        const metadata: ApiMetadata = Reflect.getMetadata(
          API_METADATA_KEY,
          MultipleApiDecorators,
        );

        // In TypeScript decorators, the bottom decorator is applied first
        expect(metadata.basePath).toBe('/first');
      }).not.toThrow();
    });

    it('should handle complex inheritance chains', () => {
      @api('/grandparent')
      class GrandParentApi {
        @endpoint(HttpMethod.GET, '/grandparent')
        grandParentMethod() {
          throw autoGeneratedError();
        }
      }

      @api('/parent')
      class ParentApi extends GrandParentApi {
        @endpoint(HttpMethod.GET, '/parent')
        parentMethod() {
          throw autoGeneratedError();
        }
      }

      @api('/child')
      class ChildApi extends ParentApi {
        @endpoint(HttpMethod.GET, '/child')
        childMethod() {
          throw autoGeneratedError();
        }
      }

      const childApi = new ChildApi();

      // All methods from inheritance chain should be decorated
      expect(typeof childApi.grandParentMethod).toBe('function');
      expect(typeof childApi.parentMethod).toBe('function');
      expect(typeof childApi.childMethod).toBe('function');

      // Child metadata should override all
      const childMetadata: ApiMetadata = Reflect.getMetadata(
        API_METADATA_KEY,
        ChildApi,
      );
      expect(childMetadata.basePath).toBe('/child');
    });

    it('should handle methods with complex parameter metadata', () => {
      @api('/test')
      class ComplexParamApi {
        @endpoint(HttpMethod.POST, '/complex')
        complexMethod(
          @parameter(ParameterType.BODY, 'data') data: any,
          @parameter(ParameterType.QUERY, 'filter') filter: string,
          @parameter(ParameterType.HEADER, 'auth') auth: string,
        ) {
          throw autoGeneratedError();
        }
      }

      const complexApi = new ComplexParamApi();
      expect(typeof complexApi.complexMethod).toBe('function');

      // Method should be decorated and return a promise
      const result = complexApi.complexMethod({}, 'test', 'token');
      expect(result).toBeInstanceOf(Promise);
    });
  });

  describe('bindExecutor internal behavior', () => {
    it('should skip constructor binding', () => {
      // Constructor should remain unchanged after decoration
      expect(TestApi.prototype.constructor).toBe(TestApi);
    });

    it('should skip non-function properties', () => {
      // Already tested in existing tests - non-function properties remain unchanged
      const testApi = new TestApi();
      expect(testApi.nonFunctionProperty).toBe('value');
    });

    it('should handle methods without endpoint metadata', () => {
      // Already tested - methods without @endpoint remain unchanged
      const testApi = new TestApi();
      expect(testApi.notDecoratedMethod()).toBe('not decorated');
    });
  });

  describe('method replacement behavior', () => {
    it('should replace method with async function', () => {
      const testApi = new TestApi();
      // Decorated methods should return promises when called
      const result = testApi.getUsers();
      expect(result).toBeInstanceOf(Promise);
    });

    it('should handle method overriding in inheritance', () => {
      @api('/base')
      class BaseOverrideApi {
        @endpoint(HttpMethod.GET, '/method')
        overrideMethod() {
          throw autoGeneratedError();
        }
      }

      @api('/child')
      class ChildOverrideApi extends BaseOverrideApi {
        @endpoint(HttpMethod.POST, '/method')
        overrideMethod() {
          throw autoGeneratedError();
        }
      }

      const childApi = new ChildOverrideApi();
      expect(typeof childApi.overrideMethod).toBe('function');

      // Child method should override parent
      const childMetadata: ApiMetadata = Reflect.getMetadata(
        API_METADATA_KEY,
        ChildOverrideApi,
      );
      expect(childMetadata.basePath).toBe('/child');
    });

    it('should preserve method arity', () => {
      const testApi = new TestApi();
      // Decorated methods should still be callable with correct number of parameters
      expect(typeof testApi.getUser).toBe('function');
      // getUser expects 1 parameter (id)
      expect(testApi.getUser.length).toBe(0); // Replaced function has no formal parameters
    });
  });

  describe('advanced metadata merging', () => {
    it('should merge complex metadata correctly', () => {
      const testApi: any = new TestApi();

      // Set complex instance metadata
      testApi.apiMetadata = {
        basePath: '/instance',
        headers: { 'X-Instance': 'value' },
        timeout: 2000,
        fetcher: 'instanceFetcher',
        resultExtractor: JsonResultExtractor,
        attributes: { instanceAttr: 'value' },
        urlParams: { instanceParam: 'value' },
      };

      const functionMetadata = new FunctionMetadata(
        'getUsers',
        {
          basePath: '/function',
          headers: { 'X-Function': 'value' },
          timeout: 5000,
          fetcher: 'functionFetcher',
          resultExtractor: JsonResultExtractor,
          attributes: { functionAttr: 'value' },
          urlParams: {},
        },
        { method: HttpMethod.GET, path: '/users' },
        new Map(),
      );

      const requestExecutor = buildRequestExecutor(testApi, functionMetadata);

      expect(requestExecutor).toBeInstanceOf(RequestExecutor);
      // Instance metadata should override function metadata
    });

    it('should handle undefined metadata fields', () => {
      const testApi: any = new TestApi();

      // Set partial instance metadata
      testApi.apiMetadata = {
        basePath: '/instance',
        // Other fields undefined
      };

      const functionMetadata = new FunctionMetadata(
        'getUsers',
        {
          timeout: 5000,
          headers: { 'X-Function': 'value' },
        },
        { method: HttpMethod.GET, path: '/users' },
        new Map(),
      );

      const requestExecutor = buildRequestExecutor(testApi, functionMetadata);

      expect(requestExecutor).toBeInstanceOf(RequestExecutor);
      // Should merge defined fields correctly
    });
  });

  describe('buildRequestExecutor', () => {
    it('should create a new request executor when none exists', () => {
      const testApi = new TestApi();
      const functionMetadata = new FunctionMetadata(
        'getUsers',
        {},
        { method: HttpMethod.GET, path: '/users' },
        new Map(),
      );

      const requestExecutor = buildRequestExecutor(testApi, functionMetadata);

      expect(requestExecutor).toBeInstanceOf(RequestExecutor);
      // Check that it's stored for reuse
      const requestExecutor2 = buildRequestExecutor(testApi, functionMetadata);
      expect(requestExecutor2).toBe(requestExecutor);
    });

    it('should reuse existing request executor', () => {
      const testApi = new TestApi();
      const functionMetadata = new FunctionMetadata(
        'getUser',
        {},
        { method: HttpMethod.GET, path: '/users/{id}' },
        new Map(),
      );

      const requestExecutor1 = buildRequestExecutor(testApi, functionMetadata);
      const requestExecutor2 = buildRequestExecutor(testApi, functionMetadata);

      expect(requestExecutor1).toBeInstanceOf(RequestExecutor);
      expect(requestExecutor1).toBe(requestExecutor2);
    });

    it('should merge api metadata correctly', () => {
      const testApi: any = new TestApi();
      // Add target api metadata
      testApi.apiMetadata = {
        basePath: '/target',
        headers: { 'X-Target': 'value' },
      };

      const functionMetadata = new FunctionMetadata(
        'getUsers',
        { basePath: '/function', timeout: 5000 },
        { method: HttpMethod.GET, path: '/users' },
        new Map(),
      );

      const requestExecutor = buildRequestExecutor(testApi, functionMetadata);

      expect(requestExecutor).toBeInstanceOf(RequestExecutor);
      // Should use target metadata where it exists, and function metadata where it doesn't
      // In this case, target metadata should take precedence
    });

    it('should create new requestExecutors map when none exists', () => {
      const testApi: any = new TestApi();
      // Remove any existing requestExecutors
      delete testApi.requestExecutors;

      const functionMetadata = new FunctionMetadata(
        'newMethod',
        {},
        { method: HttpMethod.GET, path: '/new' },
        new Map(),
      );

      const requestExecutor = buildRequestExecutor(testApi, functionMetadata);

      expect(requestExecutor).toBeInstanceOf(RequestExecutor);
      expect(testApi.requestExecutors).toBeInstanceOf(Map);
      expect(testApi.requestExecutors.get('newMethod')).toBe(requestExecutor);
    });
  });
});
