import { describe, it, expect, vi } from 'vitest';
import 'reflect-metadata';
import { JsonResultExtractor, HttpMethod } from '@ahoo-wang/fetcher';
import { api, API_METADATA_KEY, type ApiMetadata, buildRequestExecutor } from '../src';
import { endpoint } from '../src';
import { parameter, ParameterType } from '../src';
import { autoGeneratedError } from '../src';
import { RequestExecutor } from '../src';
import { FunctionMetadata } from '../src';

// Mock class for testing decorators
@api('/api/v1', {
  headers: { 'X-Default': 'value' },
  timeout: 3000,
  resultExtractor: JsonResultExtractor,
})
class TestApi {
  @endpoint(HttpMethod.GET, '/users')
  getUsers() {
    throw autoGeneratedError();
  }

  @endpoint(HttpMethod.GET, '/users/{id}')
  getUser(@parameter(ParameterType.PATH, 'id') id: string) {
    throw autoGeneratedError();
  }

  notDecoratedMethod() {
    return 'not decorated';
  }

  nonFunctionProperty = 'value';
}

// Another test class with minimal configuration
@api()
class MinimalApi {
  @endpoint(HttpMethod.POST, '/data')
  postData() {
    throw autoGeneratedError();
  }
}

describe('apiDecorator', () => {
  describe('API_METADATA_KEY', () => {
    it('should define API metadata key symbol', () => {
      expect(API_METADATA_KEY).toBeTypeOf('symbol');
    });
  });

  describe('api', () => {
    it('should create API decorator with base path and metadata', () => {
      const metadata: ApiMetadata = Reflect.getMetadata(
        API_METADATA_KEY,
        TestApi,
      );

      expect(metadata).toBeDefined();
      expect(metadata.basePath).toBe('/api/v1');
      expect(metadata.headers).toEqual({ 'X-Default': 'value' });
      expect(metadata.timeout).toBe(3000);
      expect(metadata.resultExtractor).toBe(JsonResultExtractor);
    });

    it('should create API decorator with default parameters', () => {
      const metadata: ApiMetadata = Reflect.getMetadata(
        API_METADATA_KEY,
        MinimalApi,
      );

      expect(metadata).toBeDefined();
      expect(metadata.basePath).toBe('');
      expect(metadata.headers).toBeUndefined();
      expect(metadata.timeout).toBeUndefined();
      expect(metadata.resultExtractor).toBeUndefined();
      expect(metadata.fetcher).toBeUndefined();
    });

    it('should store metadata on the class constructor', () => {
      const metadata: ApiMetadata = Reflect.getMetadata(
        API_METADATA_KEY,
        TestApi,
      );

      expect(metadata).toBeDefined();
      expect(metadata.basePath).toBe('/api/v1');
    });

    it('should replace decorated methods with executable functions', () => {
      const testApi = new TestApi();

      expect(typeof testApi.getUsers).toBe('function');
      expect(typeof testApi.getUser).toBe('function');
      // Non-decorated methods should remain unchanged
      expect(typeof testApi.notDecoratedMethod).toBe('function');
      expect(testApi.nonFunctionProperty).toBe('value');
    });

    it('should preserve non-decorated methods and properties', () => {
      const testApi = new TestApi();

      expect(testApi.notDecoratedMethod()).toBe('not decorated');
      expect(testApi.nonFunctionProperty).toBe('value');
    });

    it('should handle class with no endpoint decorators', () => {
      @api('/test')
      class NoEndpointsApi {
        regularMethod() {
          return 'regular';
        }
      }

      const metadata: ApiMetadata = Reflect.getMetadata(
        API_METADATA_KEY,
        NoEndpointsApi,
      );

      expect(metadata).toBeDefined();
      expect(metadata.basePath).toBe('/test');

      const noEndpointsApi = new NoEndpointsApi();
      expect(noEndpointsApi.regularMethod()).toBe('regular');
    });

    it('should handle class with mixed decorated and non-decorated methods', () => {
      @api('/mixed')
      class MixedApi {
        @endpoint(HttpMethod.GET, '/endpoint')
        decoratedMethod() {
          throw autoGeneratedError();
        }

        nonDecoratedMethod() {
          return 'non-decorated';
        }

        anotherNonDecoratedMethod() {
          return 'another non-decorated';
        }
      }

      const metadata: ApiMetadata = Reflect.getMetadata(
        API_METADATA_KEY,
        MixedApi,
      );

      expect(metadata).toBeDefined();
      expect(metadata.basePath).toBe('/mixed');

      const mixedApi = new MixedApi();
      expect(typeof mixedApi.decoratedMethod).toBe('function');
      expect(mixedApi.nonDecoratedMethod()).toBe('non-decorated');
      expect(mixedApi.anotherNonDecoratedMethod()).toBe(
        'another non-decorated',
      );
    });
  });

  describe('bindExecutor', () => {
    it('should not bind executor to constructor', () => {
      // This test ensures that the constructor is not modified by the decorator
      expect(TestApi.prototype.constructor).toBe(TestApi);
    });

    it('should not bind executor to non-function properties', () => {
      const testApi = new TestApi();
      // Non-function properties should remain unchanged
      expect(testApi.nonFunctionProperty).toBe('value');
    });

    it('should not bind executor to methods without endpoint metadata', () => {
      const testApi = new TestApi();
      // Methods without @endpoint decorator should remain unchanged
      expect(testApi.notDecoratedMethod()).toBe('not decorated');
    });

    it('should bind executor to decorated methods', () => {
      const testApi = new TestApi();
      // Decorated methods should be replaced with functions
      expect(typeof testApi.getUsers).toBe('function');
      expect(typeof testApi.getUser).toBe('function');
    });
  });

  describe('buildRequestExecutor', () => {
    it('should create a new request executor when none exists', () => {
      const testApi = new TestApi();
      const functionMetadata = new FunctionMetadata(
        'getUsers',
        {},
        { method: HttpMethod.GET, path: '/users' },
        new Map(),
      );

      const requestExecutor = buildRequestExecutor(testApi, functionMetadata);

      expect(requestExecutor).toBeInstanceOf(RequestExecutor);
      // Check that it's stored for reuse
      const requestExecutor2 = buildRequestExecutor(testApi, functionMetadata);
      expect(requestExecutor2).toBe(requestExecutor);
    });

    it('should reuse existing request executor', () => {
      const testApi = new TestApi();
      const functionMetadata = new FunctionMetadata(
        'getUser',
        {},
        { method: HttpMethod.GET, path: '/users/{id}' },
        new Map(),
      );

      const requestExecutor1 = buildRequestExecutor(testApi, functionMetadata);
      const requestExecutor2 = buildRequestExecutor(testApi, functionMetadata);

      expect(requestExecutor1).toBeInstanceOf(RequestExecutor);
      expect(requestExecutor1).toBe(requestExecutor2);
    });

    it('should merge api metadata correctly', () => {
      const testApi: any = new TestApi();
      // Add target api metadata
      testApi.apiMetadata = { 
        basePath: '/target',
        headers: { 'X-Target': 'value' },
      };

      const functionMetadata = new FunctionMetadata(
        'getUsers',
        { basePath: '/function', timeout: 5000 },
        { method: HttpMethod.GET, path: '/users' },
        new Map(),
      );

      const requestExecutor = buildRequestExecutor(testApi, functionMetadata);

      expect(requestExecutor).toBeInstanceOf(RequestExecutor);
      // Should use target metadata where it exists, and function metadata where it doesn't
      // In this case, target metadata should take precedence
    });

    it('should create new requestExecutors map when none exists', () => {
      const testApi: any = new TestApi();
      // Remove any existing requestExecutors
      delete testApi.requestExecutors;

      const functionMetadata = new FunctionMetadata(
        'newMethod',
        {},
        { method: HttpMethod.GET, path: '/new' },
        new Map(),
      );

      const requestExecutor = buildRequestExecutor(testApi, functionMetadata);

      expect(requestExecutor).toBeInstanceOf(RequestExecutor);
      expect(testApi.requestExecutors).toBeInstanceOf(Map);
      expect(testApi.requestExecutors.get('newMethod')).toBe(requestExecutor);
    });
  });
});