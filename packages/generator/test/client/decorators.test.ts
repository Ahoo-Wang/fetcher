/*
 * Copyright [2021-present] [ahoo wang <ahoowang@qq.com> (https://github.com/Ahoo-Wang)].
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *      http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { describe, expect, it, vi } from 'vitest';
import { ClassDeclaration, Scope, SourceFile } from 'ts-morph';
import {
  DECORATOR_MODULE_SPECIFIER,
  DECORATOR_NAMED_IMPORTS,
  STREAM_RESULT_EXTRACTOR_METADATA,
  addImportDecorator,
  createDecoratorClass,
  addApiMetadataCtor,
} from '../../src/client';

// Mock the utils module
vi.mock('../../src/utils', () => ({
  addImport: vi.fn(),
}));

describe('decorators', () => {
  describe('constants', () => {
    it('should have correct DECORATOR_MODULE_SPECIFIER', () => {
      expect(DECORATOR_MODULE_SPECIFIER).toBe('@ahoo-wang/fetcher-decorator');
    });

    it('should have correct DECORATOR_NAMED_IMPORTS', () => {
      expect(DECORATOR_NAMED_IMPORTS).toEqual([
        'type ApiMetadata',
        'type ApiMetadataCapable',
        'type ParameterRequest',
        'api',
        'get',
        'post',
        'put',
        'patch',
        'del',
        'request',
        'attribute',
        'path',
        'autoGeneratedError',
      ]);
    });

    it('should have correct STREAM_RESULT_EXTRACTOR_METADATA', () => {
      expect(STREAM_RESULT_EXTRACTOR_METADATA).toBe(`{
  headers: { Accept: ContentTypeValues.TEXT_EVENT_STREAM },
  resultExtractor: JsonEventStreamResultExtractor,
}`);
    });
  });

  describe('addImportDecorator', () => {
    it('should call addImport with correct parameters', async () => {
      const mockSourceFile = {} as SourceFile;
      const { addImport } = vi.mocked(await import('../../src/utils'));

      addImportDecorator(mockSourceFile);

      expect(addImport).toHaveBeenCalledWith(
        mockSourceFile,
        DECORATOR_MODULE_SPECIFIER,
        DECORATOR_NAMED_IMPORTS,
      );
    });
  });

  describe('createDecoratorClass', () => {
    it('should create class with api decorator and no args', () => {
      const mockSourceFile = {
        addClass: vi.fn(() => ({}) as ClassDeclaration),
      } as any;
      const className = 'TestClass';

      const result = createDecoratorClass(className, mockSourceFile);

      expect(mockSourceFile.addClass).toHaveBeenCalledWith({
        name: className,
        isExported: true,
        typeParameters: [],
        decorators: [
          {
            name: 'api',
            arguments: [],
          },
        ],
      });
      expect(result).toBeDefined();
    });

    it('should create class with api decorator and args', () => {
      const mockSourceFile = {
        addClass: vi.fn(() => ({}) as ClassDeclaration),
      } as any;
      const className = 'TestClass';
      const apiArgs = ['arg1', 'arg2'];

      const result = createDecoratorClass(className, mockSourceFile, apiArgs);

      expect(mockSourceFile.addClass).toHaveBeenCalledWith({
        name: className,
        isExported: true,
        typeParameters: [],
        decorators: [
          {
            name: 'api',
            arguments: apiArgs,
          },
        ],
      });
      expect(result).toBeDefined();
    });
  });

  describe('addApiMetadataCtor', () => {
    it('should add implements and constructor with required parameter', () => {
      const mockClassDeclaration = {
        addImplements: vi.fn(),
        addConstructor: vi.fn(),
      } as any;

      addApiMetadataCtor(mockClassDeclaration);

      expect(mockClassDeclaration.addImplements).toHaveBeenCalledWith(
        'ApiMetadataCapable',
      );
      expect(mockClassDeclaration.addConstructor).toHaveBeenCalledWith({
        parameters: [
          {
            name: 'apiMetadata',
            type: 'ApiMetadata',
            hasQuestionToken: true,
            scope: Scope.Public,
            isReadonly: true,
            initializer: undefined,
          },
        ],
      });
    });

    it('should add implements and constructor with initializer', () => {
      const mockClassDeclaration = {
        addImplements: vi.fn(),
        addConstructor: vi.fn(),
      } as any;
      const initializer = '{}';

      addApiMetadataCtor(mockClassDeclaration, initializer);

      expect(mockClassDeclaration.addImplements).toHaveBeenCalledWith(
        'ApiMetadataCapable',
      );
      expect(mockClassDeclaration.addConstructor).toHaveBeenCalledWith({
        parameters: [
          {
            name: 'apiMetadata',
            type: 'ApiMetadata',
            hasQuestionToken: false,
            scope: Scope.Public,
            isReadonly: true,
            initializer,
          },
        ],
      });
    });
  });
});
