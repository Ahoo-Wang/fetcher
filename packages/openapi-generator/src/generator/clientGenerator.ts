import { mkdirSync } from 'fs';
import { dirname, join } from 'path';
import type { ParsedOpenAPI, ParsedSchema } from '../types';

export function generateClients(
  openapi: ParsedOpenAPI,
  outputPath: string,
): void {
  const tagOperations = new Map<string, any[]>();

  for (const operation of openapi.operations) {
    for (const tag of operation.tags) {
      if (!tagOperations.has(tag)) {
        tagOperations.set(tag, []);
      }
      tagOperations.get(tag)!.push(operation);
    }
  }

  for (const [tag, operations] of tagOperations) {
    const { filePath, interfaceName } = parseTagName(tag);
    const fullPath = join(outputPath, filePath);
    mkdirSync(dirname(fullPath), { recursive: true });

    // Collect all types used in this client
    const usedTypes = new Set<string>();
    for (const operation of operations) {
      // Return type
      const returnType = getOperationReturnType(operation, openapi.schemas);
      collectTypesFromTypeString(returnType, usedTypes);

      // Parameter types
      const params = getOperationParameters(operation, openapi.schemas);
      for (const param of params) {
        collectTypesFromTypeString(param.type, usedTypes);
      }
    }

    // Build the file content as string
    let content = '';

    // Add imports for types
    const typeImports: string[] = [];
    for (const typeName of usedTypes) {
      if (
        typeName !== 'any' &&
        typeName !== 'string' &&
        typeName !== 'number' &&
        typeName !== 'boolean' &&
        !typeName.includes('Record<') &&
        !typeName.includes('Promise<') &&
        !typeName.includes('[]') &&
        !typeName.includes('|') &&
        !typeName.includes('&')
      ) {
        typeImports.push(typeName);
      }
    }
    if (typeImports.length > 0) {
      const typesPath = getRelativeTypesPath(tag);
      content += `import { ${typeImports.sort().join(', ')} } from '${typesPath}';\n`;
    }

    // Add imports for decorator functions
    content += `import { api, get, post, put, del, patch, head, options, autoGeneratedError } from "@ahoo-wang/fetcher-decorator";\n\n`;

    // Add class
    content += `@api('${tag}')\n`;
    content += `export class ${interfaceName} {\n`;

    for (const operation of operations) {
      const methodName = getOperationMethodName(operation);
      const returnType = `Promise<${getOperationReturnType(operation, openapi.schemas)}>`;
      const httpDecorator = getHttpMethodDecorator(operation.method);
      const params = getOperationParameters(operation, openapi.schemas);

      content += `    @${httpDecorator}('${operation.path}')\n`;
      content += `    ${methodName}(${params.map(p => `${p.name}${p.hasQuestionToken ? '?' : ''}: ${p.type}`).join(', ')}): ${returnType} {\n`;
      content += `        throw autoGeneratedError();\n`;
      content += `    }\n\n`;
    }

    content += `}\n`;

    // Write the file
    const fs = require('fs');
    fs.writeFileSync(fullPath, content);
  }
}

function getOperationReturnType(
  operation: any,
  schemas: Record<string, ParsedSchema>,
): string {
  // Find the 200 response
  const response200 = operation.responses?.['200'];
  if (!response200) {
    return 'any';
  }

  // Check content types
  const content = response200.content;
  if (!content) {
    return 'any';
  }

  // Check all content types
  const schema =
    content['application/json']?.schema ||
    content['*/*']?.schema ||
    content['text/event-stream']?.schema ||
    (Object.values(content)[0] as any)?.schema; // Fallback to first content type

  if (!schema) {
    return 'any';
  }

  return getTypeFromSchema(schema, schemas);
}

function getTypeFromSchema(
  schema: any,
  schemas: Record<string, ParsedSchema>,
): string {
  if (!schema || typeof schema !== 'object') {
    return 'any';
  }

  // Handle $ref references
  if (schema.$ref) {
    const refKey = schema.$ref.replace('#/components/schemas/', '');
    const refSchema = schemas[refKey];
    if (refSchema) {
      // For Wow types, use the Wow type directly
      if (refSchema.isWowType && refSchema.wowType) {
        return refSchema.wowType;
      }
      return refSchema.interfaceName;
    }
    return 'any';
  }

  if (schema.type) {
    switch (schema.type) {
      case 'string':
        if (schema.enum) {
          return schema.enum.map((val: any) => `'${val}'`).join(' | ');
        }
        return 'string';
      case 'number':
      case 'integer':
        return 'number';
      case 'boolean':
        return 'boolean';
      case 'array':
        const itemsType = schema.items
          ? getTypeFromSchema(schema.items, schemas)
          : 'any';
        return `${itemsType}[]`;
      case 'object':
        if (schema.additionalProperties) {
          const valueType = getTypeFromSchema(
            schema.additionalProperties,
            schemas,
          );
          return `Record<string, ${valueType}>`;
        }
        return 'Record<string, any>';
      default:
        return 'any';
    }
  }

  if (schema.oneOf || schema.anyOf || schema.allOf) {
    const schemasList = schema.oneOf || schema.anyOf || schema.allOf || [];
    const types = schemasList.map((s: any) => getTypeFromSchema(s, schemas));
    const joiner = schema.oneOf ? ' | ' : schema.anyOf ? ' | ' : ' & ';
    return types.join(joiner);
  }

  if (schema.oneOf || schema.anyOf || schema.allOf) {
    const schemasList = schema.oneOf || schema.anyOf || schema.allOf || [];
    const types = schemasList.map((s: any) => getTypeFromSchema(s, schemas));
    const joiner = schema.oneOf ? ' | ' : schema.anyOf ? ' | ' : ' & ';
    return types.join(joiner);
  }

  return 'any';
}

function parseTagName(tag: string): {
  filePath: string;
  interfaceName: string;
} {
  const parts = tag.split('.');

  if (parts.length === 1) {
    return {
      filePath: `./${parts[0]}Client.ts`,
      interfaceName: `${parts[0]}Client`,
    };
  }

  const interfaceName = parts[parts.length - 1];

  // For tags like "example.cart", we want "cart/cartClient.ts"
  const filePath = `${interfaceName}/${interfaceName}Client.ts`;

  return {
    filePath,
    interfaceName: `${interfaceName.charAt(0).toUpperCase() + interfaceName.slice(1)}Client`,
  };
}

function getOperationMethodName(operation: any): string {
  if (operation.operation.operationId) {
    // Clean up operationId by removing tag prefix and making it a valid identifier
    let operationId = operation.operation.operationId;
    const tagPrefix = operation.tags[0] + '.';
    if (operationId.startsWith(tagPrefix)) {
      operationId = operationId.substring(tagPrefix.length);
    }
    // Replace dots and other invalid characters with underscores
    return operationId.replace(/[^a-zA-Z0-9_]/g, '_');
  }

  const pathParts = operation.path.split('/').filter(Boolean);
  const lastPart = pathParts[pathParts.length - 1] || 'item';

  return `${operation.method}${lastPart.charAt(0).toUpperCase() + lastPart.slice(1)}`;
}

function getHttpMethodDecorator(method: string): string {
  const methodMap: Record<string, string> = {
    get: 'get',
    post: 'post',
    put: 'put',
    delete: 'del',
    patch: 'patch',
    head: 'head',
    options: 'options',
  };
  return methodMap[method] || method;
}

function getOperationParameters(
  operation: any,
  schemas: Record<string, ParsedSchema>,
): any[] {
  const parameters: any[] = [];

  // Handle path parameters first (in path order)
  const pathParams: any[] = [];
  const queryParams: any[] = [];

  if (operation.parameters) {
    for (const param of operation.parameters) {
      if (param.in === 'path') {
        const paramType = param.schema
          ? getTypeFromSchema(param.schema, schemas)
          : 'string';
        pathParams.push({
          name: param.name,
          type: paramType,
          hasQuestionToken: !param.required,
        });
      } else if (param.in === 'query') {
        const paramType = param.schema
          ? getTypeFromSchema(param.schema, schemas)
          : 'string';
        queryParams.push({
          name: param.name,
          type: paramType,
          hasQuestionToken: !param.required,
        });
      }
    }
  }

  // Sort path parameters by their order in the path
  const pathTemplate = operation.path;
  pathParams.sort((a, b) => {
    const aIndex = pathTemplate.indexOf(`{${a.name}}`);
    const bIndex = pathTemplate.indexOf(`{${b.name}}`);
    return aIndex - bIndex;
  });

  // Add sorted parameters
  parameters.push(...pathParams, ...queryParams);

  // Handle request body
  if (operation.requestBody && operation.requestBody.content) {
    for (const [, content] of Object.entries(operation.requestBody.content) as [
      string,
      any,
    ][]) {
      if (content.schema) {
        const bodyType = getTypeFromSchema(content.schema, schemas);
        parameters.push({
          name: 'body',
          type: bodyType,
          hasQuestionToken: !operation.requestBody.required,
        });
        break; // Only handle the first content type
      }
    }
  }

  return parameters;
}

function collectTypesFromTypeString(typeStr: string, types: Set<string>): void {
  // Simple type extraction - split on common separators and collect identifiers
  const parts = typeStr
    .split(/[\s\[\]|&<>]+/)
    .filter(
      part =>
        part.length > 0 &&
        part !== 'Promise' &&
        part !== 'Record' &&
        part !== 'string' &&
        part !== 'number' &&
        part !== 'boolean' &&
        part !== 'any',
    );
  for (const part of parts) {
    types.add(part);
  }
}

function getRelativeTypesPath(tag: string): string {
  // For tag "example.cart", types are in "../example/cart/types"
  const parts = tag.split('.');
  if (parts.length >= 2) {
    const context = parts[0];
    const name = parts[1];
    return `../${context}/${name}/types`;
  }
  // Special mappings for known tags
  if (tag === 'cart-controller') {
    return '../example/cart/types';
  }
  if (tag === 'order-query-controller') {
    return '../example/order/types';
  }
  if (tag === 'example.order') {
    return '../example/order/types';
  }
  return './types';
}
