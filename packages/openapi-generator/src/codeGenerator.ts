/*
 * Copyright [2021-present] [ahoo wang <ahoowang@qq.com> (https://github.com/Ahoo-Wang)].
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *      http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { ModuleDefinition } from '@/module/moduleDefinition.ts';
import { Project, SourceFile } from 'ts-morph';
import { ModelDefinition } from '@/model/modelDefinition.ts';
import { join } from 'path';
import { ClientDefinition } from '@/client/clientDefinition.ts';

export class CodeGenerator {
  constructor(
    private readonly outDir: string,
    private readonly project: Project,
  ) {
  }

  generate(modules: ModuleDefinition[]): void {
    modules.forEach(module => {
      this.generateModule(module);
      this.generateClient(module);
    });
    this.project.saveSync();
  }

  generateModule(module: ModuleDefinition): void {
    const modulePath = join(this.outDir, module.path, 'types.ts');
    const moduleFile = this.project.createSourceFile(modulePath, '', {
      overwrite: true,
    });
    module.getDependencies().forEach(dep => {
      moduleFile.addImportDeclaration({
        moduleSpecifier: dep.moduleSpecifier,
        namedImports: [...dep.namedImports],
      });
    });
    module.getModels().forEach(model => {
      this.generateModel(moduleFile, model);
    });
  }

  generateModel(moduleFile: SourceFile, model: ModelDefinition): void {
    if (model.isReference) {
      return;
    }
    const modelInterface = moduleFile.addInterface({
      name: model.name,
      isExported: true,
    });
    if (model.description) {
      modelInterface.addJsDoc({
        description: model.description,
      });
    }
    if (model.properties) {
      model.properties.forEach((type, name) => {
        modelInterface.addProperty({
          name,
          type,
        });
      });
    }
  }

  generateClient(module: ModuleDefinition): void {
    const clientName = module.getClients()[0]?.name;
    if (!clientName) return;
    const modulePath = join(this.outDir, module.path, `${clientName}.ts`);
    const moduleFile = this.project.createSourceFile(modulePath, '', {
      overwrite: true,
    });
    moduleFile.addImportDeclaration({
      moduleSpecifier: '@ahoo-wang/fetcher-decorator',
      namedImports: ['api', 'get', 'post', 'put', 'del', 'patch', 'head', 'options', 'autoGeneratedError'],
    });
    module.getDependencies().forEach(dep => {
      moduleFile.addImportDeclaration({
        moduleSpecifier: dep.moduleSpecifier,
        namedImports: [...dep.namedImports],
      });
    });
    module.getClients().forEach(client => {
      this.generateClientClass(moduleFile, client);
    });
  }

  generateClientClass(moduleFile: SourceFile, client: ClientDefinition): void {
    // Build the class as a string since ts-morph has issues with method insertion
    let classContent = `@api('${client.tag}')\nexport class ${client.name} {\n`;

    client.endpoints.forEach(endpoint => {
      // Add HTTP method decorator
      const httpDecorator = this.getHttpDecorator(endpoint.method);
      const pathParam = endpoint.path ? `('${endpoint.path}')` : '()';

      let methodStr = `  @${httpDecorator}${pathParam}\n`;

      if (endpoint.requestBody) {
        methodStr += `  @request()\n`;
        methodStr += `  ${endpoint.name}(request: ${endpoint.requestBody.name}): Promise<${endpoint.response?.name ?? 'any'}> {\n    throw autoGeneratedError();\n  }\n`;
      } else {
        methodStr += `  ${endpoint.name}(): Promise<${endpoint.response?.name ?? 'any'}> {\n    throw autoGeneratedError();\n  }\n`;
      }

      classContent += methodStr;
    });

    classContent += '}\n';

    // Add the class content to the file
    moduleFile.addStatements(classContent);
  }

  private getHttpDecorator(method: string): string {
    switch (method.toLowerCase()) {
      case 'get':
        return 'get';
      case 'post':
        return 'post';
      case 'put':
        return 'put';
      case 'delete':
        return 'del';
      case 'patch':
        return 'patch';
      case 'head':
        return 'head';
      case 'options':
        return 'options';
      case 'trace':
        return 'trace';
      default:
        return 'get';
    }
  }
}
