/*
 * Copyright [2021-present] [ahoo wang <ahoowang@qq.com> (https://github.com/Ahoo-Wang)].
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *      http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { useCallback } from 'react';
import { useQuery, UseQueryReturn, UseQueryOptions, useLatest } from '../core';
import { FetcherError } from '@ahoo-wang/fetcher';
import { CreateQueryApiHooksOptions } from './createExecuteApiHooks';
import {
  collectMethods,
  methodNameToHookName,
  HookName,
  QueryMethod,
  OnBeforeExecuteCallback,
} from './apiHooks';

/**
 * Options for useApiMethodQuery hook.
 * @template Q - The query type.
 * @template TData - The return type of the API method (resolved).
 * @template E - The error type.
 */
export interface UseApiMethodQueryOptions<
  Q,
  TData = any,
  E = FetcherError,
> extends Omit<UseQueryOptions<Q, TData, E>, 'execute'> {
  /**
   * Callback executed before query execution.
   * Allows users to handle abortController and inspect/modify query parameters.
   * Note: Query parameters can be modified in place for objects.
   * @param abortController - The AbortController for the request.
   * @param query - The query parameters passed to the API method (type-safe).
   *
   * @example
   * onBeforeExecute: (abortController, query) => {
   *   // query is now typed as Q
   *   if (query && typeof query === 'object') {
   *     query.timestamp = Date.now();
   *   }
   * }
   */
  onBeforeExecute?: OnBeforeExecuteCallback<Q>;
}

/**
 * The return type of createQueryApiHooks.
 * Creates a hook for each function method in the API object, prefixed with 'use' and capitalized.
 * Each hook accepts query options and returns the useQuery interface with type-safe query management.
 * @template API - The API object type.
 * @template E - The error type for all hooks (defaults to FetcherError).
 */
export type QueryAPIHooks<API extends Record<string, any>, E = FetcherError> = {
  [K in keyof API as API[K] extends QueryMethod
    ? HookName<string & K>
    : never]: API[K] extends QueryMethod<infer Q, infer R>
    ? (options?: UseApiMethodQueryOptions<Q, R, E>) => UseQueryReturn<Q, R, E>
    : never;
};

/**
 * Creates a hook function for a given API method.
 * @param method - The bound API method.
 * @returns A hook function.
 */
function createQueryHookForMethod<E>(
  method: (
    query: any,
    attributes?: Record<string, any>,
    abortController?: AbortController,
  ) => Promise<any>,
) {
  return function useApiMethodQuery(
    options?: UseApiMethodQueryOptions<any, any, E>,
  ) {
    const onBeforeExecuteRef = useLatest(options?.onBeforeExecute);
    const executeQuery = useCallback(
      async (
        query: any,
        attributes?: Record<string, any>,
        abortController?: AbortController,
      ): Promise<any> => {
        if (onBeforeExecuteRef.current) {
          onBeforeExecuteRef.current(abortController, query);
        }
        return method(query, attributes, abortController);
      },
      [onBeforeExecuteRef],
    );

    const queryOptions: UseQueryOptions<any, any, any> = {
      ...options,
      execute: executeQuery,
    };

    return useQuery(queryOptions);
  };
}

/**
 * Creates type-safe React hooks for API query methods.
 * Each API method that follows the query pattern is wrapped into a hook that extends useQuery.
 * The generated hooks provide automatic query state management, auto-execution, and error handling.
 *
 * @template API - The API object type containing query methods.
 * @param options - Configuration options including the API object.
 * @returns An object containing hooks for each API query method.
 *
 * @example
 * ```typescript
 * // Define your API service using decorators
 * import { api, get, post, patch, path, body, autoGeneratedError } from '@ahoo-wang/fetcher-decorator';
 *
 * @api('/users')
 * class UserApi {
 *   @get('')
 *   getUsers(query: UserListQuery, attributes?: Record<string, any>): Promise<User[]> {
 *     throw autoGeneratedError(query, attributes);
 *   }
 *
 *   @get('/{id}')
 *   getUser(query: { id: string }, attributes?: Record<string, any>): Promise<User> {
 *     throw autoGeneratedError(query, attributes);
 *   }
 * }
 *
 * const apiHooks = createQueryApiHooks({ api: new UserApi() });
 *
 * function UserListComponent() {
 *   const { loading, result, error, execute, setQuery, getQuery } = apiHooks.useGetUsers({
 *     initialQuery: { page: 1, limit: 10 },
 *     autoExecute: true,
 *     onBeforeExecute: (abortController, query) => {
 *       // query is fully typed as UserListQuery
 *       console.log('Executing query:', query);
 *     },
 *   });
 *
 *   const handlePageChange = (page: number) => {
 *     setQuery({ ...getQuery(), page }); // Automatically executes
 *   };
 *
 *   if (loading) return <div>Loading...</div>;
 *   if (error) return <div>Error: {error.message}</div>;
 *
 *   return (
 *     <div>
 *       <button onClick={() => handlePageChange(2)}>Go to page 2</button>
 *       {result?.map(user => (
 *         <div key={user.id}>{user.name}</div>
 *       ))}
 *     </div>
 *   );
 * }
 * ```
 */
export function createQueryApiHooks<
  API extends Record<string, any>,
  E = FetcherError,
>(options: CreateQueryApiHooksOptions<API>): QueryAPIHooks<API, E> {
  const { api } = options;

  const result = {} as any;
  const methods =
    collectMethods<
      (
        query: any,
        attributes?: Record<string, any>,
        abortController?: AbortController,
      ) => Promise<any>
    >(api);

  // Create hooks for each collected method
  methods.forEach((boundMethod, methodName) => {
    const hookName = methodNameToHookName(methodName);
    result[hookName] = createQueryHookForMethod<E>(boundMethod);
  });

  return result;
}
